import mainutils

# *******************Section-->Exceptions*****************
//overloadings of raise function

def raise(exception::KeyError ke) go
    ke.getError()
raise ends
def raise(exception::MemoryEstrangementError e) go
    e.getError()
raise ends
def raise(exception::IndexBoundError ibe) go
    ibe.getError()
raise ends
def raise(exception::ValueError ve) go
    ve.getError()
raise ends

#This function will return the memory address of an object.
def id(void* add) go
    return (long int)(add)
id ends

#This function will return an array which could be iterated using for loop.
def range(int start, int lim, int step = 1) go
    array<int> res
    for int i = start; i < lim; i+=step so
        res += i
    ends
    return res
range ends

def range(int lim, int step = 1) go
    array<int> res
    for int i = 0; i < lim; i+=step so
        res += i
    ends
    return res
range ends

////////////////////////String conversion utils////////
def tostr(int num) go
    return to_str(num)
tostr ends
def tostr(double num) go
    return to_str(num)
tostr ends
def tostr(str s) go
    return to_str(s)
tostr ends
def tostr(array<int> arr) go
    str s = "[ "
    for int i : arr so
        s += tostr(i)
        s += ", "
    ends
    return s+"]"
tostr ends
def tostr(array<str> arr) go
    str s = "[ "
    for str i : arr so
        s += "\""
        s += tostr(i)
        s += "\", "
    ends
    return s+"]"
tostr ends
def tostr(array<double> arr) go
    str s = "[ "
    for double i : arr so
        s += to_str(i)
        s += ", "
    ends
    return s+"]"
tostr ends
def tostr(dict<str,str> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<str,int> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<str,double> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends

def tostr(dict<int,str> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<int,int> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<int,double> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends

def tostr(dict<double,str> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<double,int> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends
def tostr(dict<double,double> d) go
    str s
    for var key : d.keys so
        s += tostr(key) + " : "
        s += tostr(d[key]) + ", "
    ends
    return s
tostr ends

def tostr(dict<str,array<str>> d) go;
    str s;
    for var key : d.keys so
        s += key + " : ";
        s += tostr(d[key]) + ",\n";
    ends;
    return s;
tostr ends;

//////////////////////// Smart Pointers ////////////
template<typename T>class SmartPtr go
    public:
        T* ptr;
        int free_call = 0;
        SmartPtr() go
            
        ends
        SmartPtr(T* ptr) go
            this->ptr = ptr;
        ends
        SmartPtr(T v) go
            this->ptr = new T(v);
        ends
        meth free() go
            free_call=1;
            delete this->ptr;
        ends
        
        //This method is used to allocate the memory.
        meth allocate(T val) go
            free_call = 0;
            // delete ptr;
            this->ptr = new T(val);
        ends
        ~SmartPtr() go
            if free_call == 0 so
                // char buffer[10];
                // char *ptr = new char[20];
                printf("Memory not is not deallocated so deallocating it at : ")
                printf("\033[31m%p\033[0m\n",this->ptr);
                delete ptr; 
            ends
        ends
ends

//////////////////////// IO ////////////////////////



//Function to take input
def input(str prompt = "") go
    printf("%s",prompt.Str)
    char i[900000]
    scanf("%[^\n]s",i)
    return str(i)
input ends
